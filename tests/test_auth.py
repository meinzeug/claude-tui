"""
Comprehensive Authentication System Tests.

Tests for JWT service, session management, RBAC, OAuth, and security features.
"""

import pytest
import asyncio
from datetime import datetime, timedelta, timezone
from unittest.mock import Mock, patch, AsyncMock
from uuid import uuid4, UUID

from fastapi import HTTPException
from fastapi.testclient import TestClient
import redis
from sqlalchemy.ext.asyncio import AsyncSession

from src.auth.jwt_service import JWTService, TokenPair, TokenData
from src.auth.session_manager import SessionManager, SessionData
from src.auth.oauth.github import GitHubOAuthProvider
from src.auth.oauth.google import GoogleOAuthProvider
from src.auth.audit_logger import SecurityAuditLogger, SecurityEventType, SecurityLevel
from src.middleware.rbac import RBACMiddleware, Permission, Role, RoleRegistry
from src.api.models.user import User


class TestJWTService:
    """Test JWT service functionality."""
    
    @pytest.fixture
    def mock_redis(self):
        """Mock Redis client."""
        mock_redis = Mock()
        mock_redis.setex.return_value = True
        mock_redis.hset.return_value = True
        mock_redis.hgetall.return_value = {}
        mock_redis.exists.return_value = 0
        mock_redis.delete.return_value = 1
        mock_redis.expire.return_value = True
        mock_redis.keys.return_value = []
        return mock_redis
    
    @pytest.fixture
    def jwt_service(self, mock_redis):
        """Create JWT service instance."""
        return JWTService(
            secret_key="test_secret_key",
            redis_client=mock_redis,
            access_token_expire_minutes=30,
            refresh_token_expire_days=30
        )
    
    @pytest.fixture
    def mock_user(self):
        """Create mock user."""
        user = Mock()
        user.id = uuid4()
        user.username = "testuser"
        user.email = "test@example.com"
        user.role = "developer"
        user.is_active = True
        return user
    
    @pytest.mark.asyncio
    async def test_create_token_pair(self, jwt_service, mock_user):
        """Test token pair creation."""
        session_id = "test_session_123"
        permissions = ["project:read", "project:write"]
        
        token_pair = await jwt_service.create_token_pair(
            user=mock_user,
            session_id=session_id,
            permissions=permissions,
            ip_address="192.168.1.100",
            user_agent="Test Agent"
        )\n        \n        assert isinstance(token_pair, TokenPair)\n        assert token_pair.access_token\n        assert token_pair.refresh_token\n        assert token_pair.token_type == \"bearer\"\n        assert token_pair.expires_in == 30 * 60  # 30 minutes\n        assert token_pair.user_id == str(mock_user.id)\n        assert token_pair.session_id == session_id\n        assert token_pair.permissions == permissions\n    \n    @pytest.mark.asyncio\n    async def test_validate_access_token(self, jwt_service, mock_user):\n        \"\"\"Test access token validation.\"\"\"\n        # Create token first\n        token_pair = await jwt_service.create_token_pair(\n            user=mock_user,\n            session_id=\"test_session_123\",\n            permissions=[\"project:read\"]\n        )\n        \n        # Validate token\n        token_data = await jwt_service.validate_access_token(\n            token_pair.access_token\n        )\n        \n        assert isinstance(token_data, TokenData)\n        assert token_data.user_id == str(mock_user.id)\n        assert token_data.username == mock_user.username\n        assert token_data.email == mock_user.email\n        assert token_data.role == mock_user.role\n        assert \"project:read\" in token_data.permissions\n    \n    @pytest.mark.asyncio\n    async def test_validate_expired_token(self, jwt_service, mock_user):\n        \"\"\"Test expired token validation.\"\"\"\n        # Create JWT service with very short expiration\n        short_jwt_service = JWTService(\n            secret_key=\"test_secret_key\",\n            redis_client=jwt_service.redis_client,\n            access_token_expire_minutes=0  # Immediate expiration\n        )\n        \n        token_pair = await short_jwt_service.create_token_pair(\n            user=mock_user,\n            session_id=\"test_session_123\"\n        )\n        \n        # Wait a moment for expiration\n        await asyncio.sleep(0.1)\n        \n        with pytest.raises(Exception) as exc_info:\n            await short_jwt_service.validate_access_token(\n                token_pair.access_token\n            )\n        \n        assert \"expired\" in str(exc_info.value).lower()\n    \n    @pytest.mark.asyncio\n    async def test_revoke_token(self, jwt_service, mock_user):\n        \"\"\"Test token revocation.\"\"\"\n        token_pair = await jwt_service.create_token_pair(\n            user=mock_user,\n            session_id=\"test_session_123\"\n        )\n        \n        # Revoke token\n        result = await jwt_service.revoke_token(token_pair.access_token)\n        assert result is True\n        \n        # Mock Redis to return blacklisted token\n        jwt_service.redis_client.exists.return_value = 1\n        \n        # Try to validate revoked token\n        with pytest.raises(Exception) as exc_info:\n            await jwt_service.validate_access_token(token_pair.access_token)\n        \n        assert \"revoked\" in str(exc_info.value).lower()\n    \n    @pytest.mark.asyncio\n    async def test_password_hashing(self, jwt_service):\n        \"\"\"Test password hashing and verification.\"\"\"\n        password = \"test_password_123\"\n        \n        # Hash password\n        hashed = jwt_service.hash_password(password)\n        assert hashed != password\n        assert len(hashed) > 50  # bcrypt hashes are long\n        \n        # Verify password\n        assert jwt_service.verify_password(password, hashed) is True\n        assert jwt_service.verify_password(\"wrong_password\", hashed) is False\n\n\nclass TestSessionManager:\n    \"\"\"Test session management functionality.\"\"\"\n    \n    @pytest.fixture\n    def mock_redis(self):\n        \"\"\"Mock Redis client for sessions.\"\"\"\n        mock_redis = Mock()\n        mock_redis.setex.return_value = True\n        mock_redis.get.return_value = None\n        mock_redis.delete.return_value = 1\n        mock_redis.sadd.return_value = 1\n        mock_redis.srem.return_value = 1\n        mock_redis.smembers.return_value = set()\n        mock_redis.scard.return_value = 0\n        mock_redis.keys.return_value = []\n        return mock_redis\n    \n    @pytest.fixture\n    def session_manager(self, mock_redis):\n        \"\"\"Create session manager instance.\"\"\"\n        return SessionManager(\n            redis_client=mock_redis,\n            session_timeout_minutes=480,\n            max_sessions_per_user=5\n        )\n    \n    @pytest.mark.asyncio\n    async def test_create_session(self, session_manager):\n        \"\"\"Test session creation.\"\"\"\n        session = await session_manager.create_session(\n            user_id=\"user_123\",\n            username=\"testuser\",\n            role=\"developer\",\n            ip_address=\"192.168.1.100\",\n            user_agent=\"Test Agent\"\n        )\n        \n        assert isinstance(session, SessionData)\n        assert session.user_id == \"user_123\"\n        assert session.username == \"testuser\"\n        assert session.role == \"developer\"\n        assert session.ip_address == \"192.168.1.100\"\n        assert session.is_active is True\n        assert session.session_id\n    \n    @pytest.mark.asyncio\n    async def test_session_expiration(self, session_manager):\n        \"\"\"Test session expiration logic.\"\"\"\n        # Create session with short timeout\n        short_session_manager = SessionManager(\n            redis_client=session_manager.redis_client,\n            session_timeout_minutes=0  # Immediate expiration\n        )\n        \n        session = await short_session_manager.create_session(\n            user_id=\"user_123\",\n            username=\"testuser\",\n            role=\"developer\",\n            ip_address=\"192.168.1.100\",\n            user_agent=\"Test Agent\"\n        )\n        \n        # Session should be considered expired\n        retrieved_session = await short_session_manager.get_session(session.session_id)\n        assert retrieved_session is None  # Should be None due to expiration\n    \n    @pytest.mark.asyncio\n    async def test_update_session_activity(self, session_manager):\n        \"\"\"Test session activity updates.\"\"\"\n        # Mock successful session retrieval\n        mock_session_data = {\n            \"session_id\": \"test_session_123\",\n            \"user_id\": \"user_123\",\n            \"username\": \"testuser\",\n            \"role\": \"developer\",\n            \"ip_address\": \"192.168.1.100\",\n            \"user_agent\": \"Test Agent\",\n            \"created_at\": datetime.now(timezone.utc).isoformat(),\n            \"last_activity\": datetime.now(timezone.utc).isoformat(),\n            \"expires_at\": (datetime.now(timezone.utc) + timedelta(hours=8)).isoformat(),\n            \"metadata\": {},\n            \"is_active\": True\n        }\n        \n        import json\n        session_manager.redis_client.get.return_value = json.dumps(mock_session_data)\n        session_manager.redis_client.set.return_value = True\n        \n        result = await session_manager.update_session_activity(\n            \"test_session_123\",\n            ip_address=\"192.168.1.101\",  # Different IP\n            extend_session=True\n        )\n        \n        assert result is True\n\n\nclass TestRBACMiddleware:\n    \"\"\"Test RBAC middleware functionality.\"\"\"\n    \n    @pytest.fixture\n    def role_registry(self):\n        \"\"\"Create role registry instance.\"\"\"\n        return RoleRegistry()\n    \n    @pytest.fixture\n    def mock_jwt_service(self):\n        \"\"\"Mock JWT service.\"\"\"\n        return Mock()\n    \n    @pytest.fixture\n    def rbac_middleware(self, mock_jwt_service, role_registry):\n        \"\"\"Create RBAC middleware instance.\"\"\"\n        return RBACMiddleware(\n            jwt_service=mock_jwt_service,\n            role_registry=role_registry\n        )\n    \n    @pytest.fixture\n    def token_data(self):\n        \"\"\"Create mock token data.\"\"\"\n        return TokenData(\n            user_id=\"user_123\",\n            username=\"testuser\",\n            email=\"test@example.com\",\n            role=\"developer\",\n            permissions=[\"project:read\", \"project:write\"],\n            jti=\"token_123\",\n            iat=int(datetime.now(timezone.utc).timestamp()),\n            exp=int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp())\n        )\n    \n    @pytest.mark.asyncio\n    async def test_permission_checking(self, rbac_middleware, token_data):\n        \"\"\"Test permission checking logic.\"\"\"\n        # Test direct permission\n        has_permission = await rbac_middleware.check_permission(\n            token_data,\n            Permission.PROJECT_READ\n        )\n        assert has_permission is True\n        \n        # Test missing permission\n        has_permission = await rbac_middleware.check_permission(\n            token_data,\n            Permission.USER_ADMIN\n        )\n        assert has_permission is False\n    \n    @pytest.mark.asyncio\n    async def test_role_based_permissions(self, rbac_middleware, token_data):\n        \"\"\"Test role-based permission inheritance.\"\"\"\n        # Developer should have project read permission via role\n        has_permission = await rbac_middleware.check_permission(\n            token_data,\n            Permission.PROJECT_READ\n        )\n        assert has_permission is True\n    \n    @pytest.mark.asyncio\n    async def test_admin_override(self, rbac_middleware, role_registry):\n        \"\"\"Test admin permission override.\"\"\"\n        admin_token = TokenData(\n            user_id=\"admin_123\",\n            username=\"admin\",\n            email=\"admin@example.com\",\n            role=\"admin\",\n            permissions=[],\n            jti=\"admin_token_123\",\n            iat=int(datetime.now(timezone.utc).timestamp()),\n            exp=int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp())\n        )\n        \n        # Admin should have access to everything\n        has_permission = await rbac_middleware.check_permission(\n            admin_token,\n            Permission.USER_DELETE  # Sensitive permission\n        )\n        assert has_permission is True\n    \n    def test_role_definitions(self, role_registry):\n        \"\"\"Test role definitions and inheritance.\"\"\"\n        # Test developer role permissions\n        dev_permissions = role_registry.get_role_permissions(\"developer\")\n        assert Permission.PROJECT_READ in dev_permissions\n        assert Permission.PROJECT_WRITE in dev_permissions\n        assert Permission.USER_ADMIN not in dev_permissions\n        \n        # Test admin role permissions\n        admin_permissions = role_registry.get_role_permissions(\"admin\")\n        assert Permission.USER_ADMIN in admin_permissions\n        assert Permission.PROJECT_ADMIN in admin_permissions\n\n\nclass TestOAuthProviders:\n    \"\"\"Test OAuth provider functionality.\"\"\"\n    \n    @pytest.fixture\n    def github_provider(self):\n        \"\"\"Create GitHub OAuth provider.\"\"\"\n        return GitHubOAuthProvider(\n            client_id=\"test_client_id\",\n            client_secret=\"test_client_secret\",\n            redirect_uri=\"http://localhost:8000/auth/oauth/github/callback\"\n        )\n    \n    @pytest.fixture\n    def google_provider(self):\n        \"\"\"Create Google OAuth provider.\"\"\"\n        return GoogleOAuthProvider(\n            client_id=\"test_client_id\",\n            client_secret=\"test_client_secret\",\n            redirect_uri=\"http://localhost:8000/auth/oauth/google/callback\"\n        )\n    \n    def test_authorization_url_generation(self, github_provider, google_provider):\n        \"\"\"Test OAuth authorization URL generation.\"\"\"\n        # Test GitHub\n        github_url, github_state = github_provider.get_authorization_url()\n        assert \"github.com\" in github_url\n        assert \"client_id=test_client_id\" in github_url\n        assert f\"state={github_state}\" in github_url\n        assert github_state\n        \n        # Test Google\n        google_url, google_state = google_provider.get_authorization_url()\n        assert \"accounts.google.com\" in google_url\n        assert \"client_id=test_client_id\" in google_url\n        assert f\"state={google_state}\" in google_url\n        assert google_state\n    \n    @pytest.mark.asyncio\n    @patch('httpx.AsyncClient')\n    async def test_github_user_info(self, mock_http_client, github_provider):\n        \"\"\"Test GitHub user info retrieval.\"\"\"\n        # Mock HTTP responses\n        mock_client = AsyncMock()\n        mock_http_client.return_value.__aenter__.return_value = mock_client\n        \n        # Mock user profile response\n        mock_user_response = Mock()\n        mock_user_response.status_code = 200\n        mock_user_response.json.return_value = {\n            \"id\": 12345,\n            \"login\": \"testuser\",\n            \"name\": \"Test User\",\n            \"email\": \"test@example.com\",\n            \"avatar_url\": \"https://github.com/avatar.jpg\",\n            \"html_url\": \"https://github.com/testuser\"\n        }\n        \n        # Mock email response\n        mock_email_response = Mock()\n        mock_email_response.status_code = 200\n        mock_email_response.json.return_value = [\n            {\n                \"email\": \"test@example.com\",\n                \"primary\": True,\n                \"verified\": True\n            }\n        ]\n        \n        mock_client.get.side_effect = [mock_user_response, mock_email_response]\n        \n        user_info = await github_provider.get_user_info(\"test_access_token\")\n        \n        assert user_info.provider == \"github\"\n        assert user_info.provider_id == \"12345\"\n        assert user_info.email == \"test@example.com\"\n        assert user_info.name == \"Test User\"\n        assert user_info.username == \"testuser\"\n        assert user_info.verified is True\n\n\nclass TestSecurityAuditLogger:\n    \"\"\"Test security audit logging functionality.\"\"\"\n    \n    @pytest.fixture\n    def audit_logger(self, tmp_path):\n        \"\"\"Create audit logger instance.\"\"\"\n        log_file = tmp_path / \"security.log\"\n        return SecurityAuditLogger(\n            log_file=str(log_file),\n            enable_console=False,\n            enable_file=True\n        )\n    \n    @pytest.mark.asyncio\n    async def test_log_authentication_event(self, audit_logger):\n        \"\"\"Test authentication event logging.\"\"\"\n        await audit_logger.log_authentication(\n            SecurityEventType.LOGIN_SUCCESS,\n            user_id=\"user_123\",\n            username=\"testuser\",\n            ip_address=\"192.168.1.100\",\n            session_id=\"session_123\",\n            success=True,\n            message=\"User logged in successfully\"\n        )\n        \n        # Check log file exists and contains data\n        # Note: In real tests, you'd parse the log file to verify content\n    \n    @pytest.mark.asyncio\n    async def test_log_security_incident(self, audit_logger):\n        \"\"\"Test security incident logging.\"\"\"\n        await audit_logger.log_security_incident(\n            SecurityEventType.SUSPICIOUS_ACTIVITY,\n            SecurityLevel.HIGH,\n            \"Multiple failed login attempts detected\",\n            user_id=\"user_123\",\n            ip_address=\"192.168.1.100\",\n            details={\"failed_attempts\": 10, \"time_window\": \"5_minutes\"}\n        )\n        \n        # In real tests, verify alert webhook was called for high-level events\n    \n    def test_risk_score_calculation(self, audit_logger):\n        \"\"\"Test risk score calculation logic.\"\"\"\n        # Test authentication risk score\n        score = audit_logger._calculate_auth_risk_score(\n            SecurityEventType.LOGIN_FAILED,\n            success=False,\n            details={\"failed_attempts\": 8}\n        )\n        assert score > 0\n        assert score <= 100\n        \n        # Test incident risk score\n        incident_score = audit_logger._calculate_incident_risk_score(\n            SecurityLevel.CRITICAL,\n            details={\"attack_type\": \"brute_force\"}\n        )\n        assert incident_score == 100  # Critical should be max score\n\n\nclass TestAuthenticationIntegration:\n    \"\"\"Integration tests for authentication system.\"\"\"\n    \n    @pytest.fixture\n    def app_client(self):\n        \"\"\"Create test client for FastAPI app.\"\"\"\n        # This would need to be implemented with actual FastAPI app\n        pass\n    \n    def test_login_flow(self):\n        \"\"\"Test complete login flow.\"\"\"\n        # This would test the complete authentication flow\n        # including rate limiting, session creation, token generation\n        pass\n    \n    def test_oauth_flow(self):\n        \"\"\"Test complete OAuth flow.\"\"\"\n        # This would test OAuth initiation, callback handling,\n        # user creation/login, and session establishment\n        pass\n    \n    def test_rate_limiting(self):\n        \"\"\"Test rate limiting enforcement.\"\"\"\n        # This would test that rate limits are properly enforced\n        # for authentication endpoints\n        pass\n    \n    def test_session_management(self):\n        \"\"\"Test session lifecycle management.\"\"\"\n        # This would test session creation, updates, expiration,\n        # and cleanup functionality\n        pass\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])"